<!DOCTYPE html>
<html lang="fr-CA" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="proposition theorem-like"><h4 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">7.4.10</span><span class="period">.</span>
</h4>
<div class="para">Soit <span class="process-math">\(G=(S,A)\)</span> un graphe simple connexe, alors <span class="process-math">\(G\)</span> possède un arbre couvrant <span class="process-math">\(T\text{.}\)</span>
</div></article><details class="hiddenproof born-hidden-knowl"><summary class="knowl__link"><h4 class="heading"><span class="type">Démonstration<span class="period">.</span></span></h4></summary><article class="hiddenproof knowl__content"><div class="para">On construit une suite <span class="process-math">\(G_k=(S,A_k)\)</span> de sous-graphe de <span class="process-math">\(G\)</span> par récurrence, c’est-à-dire qu’on définit <span class="process-math">\(G_0\text{,}\)</span> et ensuite, ayant défini <span class="process-math">\(G_k=(S,A_k)\)</span> pour <span class="process-math">\(k\geq 0\text{,}\)</span> on définit <span class="process-math">\(G_{k+1}\text{.}\)</span> On va continuer le processus jusqu’à ce que le graphe obtenu soit un arbre. Ce processus se terminera nécessairement en un nombre fini d’étape, disons <span class="process-math">\(n\)</span> étapes. À la fin, on posera <span class="process-math">\(T=G_n\text{.}\)</span>
</div> <div class="para">On pose <span class="process-math">\(G_0=G\text{.}\)</span> Ensuite, on suppose qu’on a défini <span class="process-math">\(G_k=(S,A_k)\)</span> un graphe simple connexe pour <span class="process-math">\(k\geq 0\text{.}\)</span> Si <span class="process-math">\(G_k\)</span> est un arbre, alors il s’agit d’un arbre couvrant pour <span class="process-math">\(G\text{,}\)</span> et on a terminé. Si au contraire <span class="process-math">\(G_k\)</span> n’est pas un arbre, on doit définir <span class="process-math">\(G_{k+1}\)</span> un graphe simple connexe contenant une arête de moins que <span class="process-math">\(G_k\text{.}\)</span>
</div> <div class="para">Puisque <span class="process-math">\(G_k\)</span> n’est pas un arbre, <span class="process-math">\(G_k\)</span> possède un cycle, disons le cycle <span class="process-math">\(s_0, s_1, \dots, s_{m-1}, s_m\text{,}\)</span> avec <span class="process-math">\(s_{m}=s_0\text{.}\)</span> On pose alors <span class="process-math">\(G_{k+1}=(S,A_{k+1}):= G_k-\{s_{m-1}, s_m\}=(S,A_k-\{s_{m-1},s_m\})\text{.}\)</span> Le graphe obtenu est donc un graphe avec les mêmes sommets que <span class="process-math">\(G\text{,}\)</span> possédant une arête de moins que le graphe <span class="process-math">\(G_k\text{.}\)</span> On doit vérifier qu’il s’agit toujours de graphe connexe. Or, par le lemme <a href="sec-arbre.html#lem-arbreCouvrant" class="xref" data-knowl="./knowl/xref/lem-arbreCouvrant.html" data-reveal-label="Dévoiler" data-close-label="Close" title="Lemme 7.4.8">7.4.8</a>, on sait que <span class="process-math">\(G_{k+1}\)</span> est connexe.</div> <div class="para">Puisqu’on enlève une arête à chaque étape, et que le nombre d’arêtes de <span class="process-math">\(G\)</span> est fini, on doit nécessairement arriver à un point où <span class="process-math">\(G_k\)</span> ne possède pas de cycle. Si le processus se termine avec <span class="process-math">\(k=n\text{,}\)</span> alors on pose <span class="process-math">\(T=G_n\text{.}\)</span> Puisque <span class="process-math">\(T\)</span> possède les mêmes sommets que <span class="process-math">\(G\text{,}\)</span> est connexe et ne possède aucun cycle. <span class="process-math">\(T\)</span> est donc bien un arbre couvrant de <span class="process-math">\(G\text{.}\)</span>
</div></article></details><span class="incontext"><a class="internal" href="sec-arbre.html#prop-arbreCouvrant">Contexte</a></span>
</body>
</html>
